1.	Что такое класс? Чем отличается класс от объекта? 
2.	Допускается ли передавать объекты в качестве параметров, и какими способами? А возвращать как результат? 
3.	Чем класс отличается от структуры? Можно ли использовать ключевые слова public и private в структуре?
4.	Объясните принцип инкапсуляции. Обязательно ли делать поля класса приватными? 
5.	Для чего используются ключевые слова public и private? Существуют ли ограничения на использование public и private в классе? 
6.	Что такое метод? Как вызывается метод? Что такое параметры значения по умолчанию?
7.	Что такое наследование?
8.	Как определить метод непосредственно внутри класса и вне класса? Чем эти определения отличаются? 
9.	Что обозначается ключевым словом this? 
10.	Зачем нужны константные методы? Чем отличается определение константного метода от обычного? 
11.	Объясните принцип полиморфизма. 
12.	Можно ли перегружать операции для встроенных типов данных? 
13.	Перечислите особенности перегрузки операций через методы класса. Чем отличается перегрузка через функции от перегрузки через методы класса? 
14.	Какой результат должны возвращать операции с присваиванием? 
15.	Какие операции разрешается перегружать только как методы класса? 
16.	Дайте определение дружественной функции. Как объявляется дружественная функция? А как определяется? 
17.	Дайте определение конструктора. Каково назначение конструктора? Перечислите отличия конструктора от метода. 
18.	Сколько конструкторов может быть в классе? Допускается ли перегрузка конструкторов? Какие виды конструкторов создаются по умолчанию? 
19.	Может ли конструктор быть приватным? Какие последствия влечет за собой объявление конструктора приватным? 
20.	Приведите несколько случаев, когда конструктор вызывается неявно. Как запретить неявное преобразование типа? 
21.	Для чего служит ключевое слово explicit? 
22.	Сколько операндов имеет операция индексирования []? Что она должна возвращать? 
23.	Для чего нужны статические поля в классе? Как они определяются? Чем отличаются от обычных полей? 
24.	Дайте определение итератора. Что играет роль итератора для массивов С++? 
25.	Что такое деструктор? Может ли деструктор иметь параметры? 
26.	Что такое перегрузка? Чем отличается перегрузка от переопределения? 
27.	Что такое конструктор копирования? Чем отличается конструктор копирования от обычного конструктора? Когда необходимо применять?
28.	Что такое односвязный список?
29.	Чем двусвязный список отличается от односвязного?
30.	Что такое очередь?
31.	Чем кольцевая очередь отличается от очереди с приоритетом?
32.	Что такое стек?
33.	Что такое бинарное дерево поиска?
34.	Что такое исключение? Назовите ключевые слова С++, которые используются для обработки исключений. 
35.	Каким образом генерируется исключение? Как перехватить исключение?
36.	Какого типа может быть исключение? 
37.	Сколько параметров разрешается писать в секции try:catch? 
38.	Напишите конструкцию, которая позволяет перехватить любое исключение. 
39.	Могут ли блоки try:catch быть вложенными? 
40.	Перечислите возможные способы выхода из блока try:catch. 

1.	Каким образом исключение <передать дальше>? 
2.	Сколько секций catch должно быть задано в блоке try? 
3.	Существуют ли стандартные исключения? Назовите два-три типа стандартных исключений.
4.	Какие виды наследования возможны в С++? 
5.	Чем отличается модификатор доступа protected от модификаторов private и public? 
6.	Чем открытое наследование отличается от закрытого и защищенного? 
7.	Каков порядок вызова конструкторов? А деструкторов? 
8.	Можно ли в производном классе объявлять новые поля? А методы? Если имя нового поля совпадает с именем унаследованного, то что тогда? 
9.	Что происходит, если имя метода-наследника совпадает с именем базового метода? 
10.	Поястните возможно ли приведение типов от базового класса к производному и обратно? 
11.	Поясните проблему множественного наследования? Какие возможны способы решения проблемы множественного наследования.
12.	Объясните, зачем нужны виртуальные функции. 
13.	Чем <раннее> связывание отличается от <позднего>? 
14.	Какие два вида полиморфизма реализованы в С++? 
15.	Дайте определение полиморфного класса. 
16.	Наследуются ли виртуальные функции? 
17.	Может ли конструктор быть виртуальным? А деструктор? 
18.	Как объявляется <чистая> виртуальная функция? Чем отличается от просто виртуальной функции?
19.	Дайте определение абстрактного класса. 
20.	Перечислите назначение наследования.
21.	Поясните как вызвать метод родительского класса если в наследнике также существует метод с такой же сигнатурой?
22.	Для чего используются пространства имен? 
23.	Могут ли пространства имен быть вложенными? 
24.	Для чего применяются псевдонимы пространства имен 
25.	В чем состоит проблема глобальных переменных? 
26.	Чем отличается статический метод от обычного? 
27.	Какие методы класса не могут быть статическими? 
28.	Какие применения статических полей вы можете привести? А каким образом применяются статические методы? 
29.	Приведите структуру и принцип действия паттерна Singleton.
30.	Для чего предназначены шаблоны?
31.	Объясните назначение ключевого слова typename.
32.	Можно ли параметрам шаблона присваивать значения по умолчанию?
33.	Зачем нужны умные указатели?
34.	Что такое <стратегия владения> умного указателя? Сколько стратегий владения вы знаете?
35.	Какие умные указатели реализован в стандартной библиотеке С++?
36.	Что такое <функтор>?
37.	Объясните, чем отличается множественное наследование от простого?
38.	Что такое <поток> - дайте определение. 
39.	Какие классы ввода/вывода реализованы в С++ и чем они отличаются? 
40.	Перечислите стандартные потоки и ввода-вывод объясните их назначение 

1.	Объясните, для чего нужны строковые потоки.
2.	С помощью каких функций выполняется работа со строковыми потоками? 
3.	Объясните, в чем заключается различие между текстовым и двоичным файлом. 
4.	Объясните, что означает <открыть> файл и <закрыть> файл? 
5.	Перечислите режимы открытия файла. Чем отличается режим ios::in от режима ios::out? 
6.	В каких случаях необходимо следить за ситуацией <конец файла>? Каким способом это делается? 
7.	Можно ли текстовый файл открыть как двоичный? А двоичный - как текстовый? 
8.	Какие функции ввода/вывода используются для обмена с текстовыми файлами? 
9.	Перечислите функции ввода/вывода для работы с двоичными файлами. 
10.	Объясните назначение методов seekg() и tellg().  
11.	В чем преимущества объектно-ориентированной библитеки по работе с файлами по сравнению с процедурной? 
12.	Каким образом ввести строку с пробелами? 
13.	Перечислите режимы открытия объектно-ориентированных файловых потоков. Каким образом комбинируются режимы открытия файлоавых потоков? 
14.	Обязательно ли закрывать файл, связанный с объектно-ориентированным файловым потоком? А открывать? 
15.	Каким образом открыть файловый поток для чтения и записи одновременно? 
16.	Как открыть файловый поток для дозаписи? 
17.	Можно ли вывести значение переменной в двоичном виде и как это сделать?  
18.	Покажите, каким образом можно выполнить перегрузку операций ввода/вывода для нового типа данных. 
19.	Перечислите последовательные контейнеры стандартной библиотеки. Чем они отличаются друг от друга? 
20.	Перечислите виды конструкторов, с помощью которых можно создавать вектор. 
21.	Можно ли инициализировать контейнер элементами массива? А элементами другого контейнера? Какими способами это можно сделать? 
22.	Какие методы реализованы в контейнере-векторе для доступа к элементам? 
23.	Отличается ли функция at() доступа по индексу от перегруженной операции индексирования и чем? 
24.	Чем метод size() отличается от метода capacity()? А в чем отличие этих методов от метода max_size()? 
25.	Какие контейнеры называются ассоциативными и почему? 
26.	Чем контейнер map отличается от контейнера multimap? 
27.	Как используется pair<> в ассоциативных контейнерах? 
28.	Какими преимуществами обладает функция make_pair() по сравнению с конструктором pair()? 
29.	Чем отличается метод c_str() от мтода data() класса string?
30.	Дайте определение итератора. 
31.	Что такое <начальный> итератор и <конечный> итератор? Какие методы, связанные с итераторами, обязательно включает каждый контейнер? 
32.	Чем константный итератор отличается от неконстантного? 
33.	Объясните, почему итераторы реализованы как вложенные классы в контейнерах. 
34.	Почему алгоритмы remove() не удаляют элементы из vector? Как реально удалить элементы из контейнера? 
35.	Какую функцию выполняет алгоритмы unique()? 
36.	Нужно ли сортировать ассоциативные контейнеры? 
37.	Какие алгоритмы предназначены для заполнения контейнера значениями? 
38.	Каким образом заполнить с помощью алгоритма generate() последовательный контейнер? 
39.	Можно ли с помощью алгоритма for_each() изменить элементы контейнера 
40.	Что такое lambda выражение? Чем отличается от функции?
41.	Что такое предикат? 